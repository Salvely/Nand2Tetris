# 中间代码生成

## 数据相关指令生成

数据的类型包括：

- 常数
- bool 值
- 数组
- 对象

重点在于(local argument object global...)：

- 数据的类型
- 数据的生存周期

### 符号表

- name
- type -> memory size different
- scope -> life cycle different

符号表有如下几种类型:

1. static: class scope
2. field: class scope
3. argument: Scope: subroutine (method/function/constructor).
4. var: Scope: subroutine (method/function/constructor).

符号表需要有如下几个值：

1. name
2. type: 如int/String/boolean
3. kind：scope，如static/field/argument/var,大的nested scope包括class和subroutine
4. index：编号

实现方法：使用两个哈希表，一个用于class，一个用于subroutine

### 变量

虽然不同的 type 对应不同的 memory size，不同的 scope 有不同的 life cycle，但是所幸我们在后端已经实现了该部分（使用不同区域的栈等），因此在这个部分我们只需要将高级语言翻译成对应的 VM
中间代码即可（栈表达式）。

### 数组

- 让一个指针指向数组的开头，其他元素通过地址索引得到

### 对象

- 让一个指针指向对象的开头，其他元素通过地址索引得到

## 代码相关指令生成

### 计算表达式

- 使用后缀表达式

### 控制流生成

- if 和 while 可以嵌套，因为编译时是递归编译的
- if 和 while 的 label 会通过后端代码生成特定的编号，防止 label 名重合
- 我们只需要实现 Jack 语言和 VM 指令的转换就行了

![控制逻辑](控制逻辑.png)

## Jack 中间代码映射规范

### 文件和函数命名

1. .jack 文件 -> .vm 文件
2. yyy(class).xxx(subroutine name) -> yyy.xxx
3. function/constructor with k args -> void function/constructor k
4. method with k args -> function with k+1 args(first arg = `this` object)

### Memory 分配和获取

1. local variable -> local segment
2. argument variable -> argument segment
3. static variable -> .vm 文件的 static segment
4. 对于类中的函数（譬如 method 或者 constructor），field of this object -> 让 this segment（pointer 0） 指向当前对象，然后使用 this index 来指向其不同的
   field，index 是个非负数
5. 在一个 VM 函数中，要获取一个数组中的元素，就需要先让 that segment（pointer 1）指向数组该元素地址，然后对该地址进行解引。

### 过程调用

1. 调用 VM 函数之前，必须把像栈上压入参数
2. 如果调用的是类内部的 method，压入的第一个参数必须是类的对象的引用
3. 编译 method -> 需要插入设置 this segment base 的代码
4. 编译 constructor -> 需要插入内存块分配 + 设置 this segment base 的代码

### 从函数和方法返回（返回值为 void）

1. Jack 返回值为 void 时，VM 代码返回 0
2. caller 需要 pop return value（是 0）

### 常数

1. `null`和`false`对应的是 0
2. `True`对应-1，可以先`push constant 1`，然后再`neg`

### 系统调用

OS 提供了一些系列的库函数，包括`Math.vm, Array.vm, Output.vm, Screen.vm, Keyboard.vm, Memory.vm, Sys.vm`。下面有几个可能用到的：

1. `Math.multiply()`和`Math.divide()`用来调用乘法和除法
2. `String.new(length)`函数构建一个新的字符串，`String.appendChar(nextChar)`向一个字符串后追加字符
3. `Memory.alloc(size)`为新的对象分配内存

## 前情提要

1. xml的tag是按照词法分析规则进行组织的，其包含几个类别：KEYWORD, SYMBOL,IDENTIFIER, INT_CONST, STRING_CONST, COMMENT
2. 大的tag是按照P225的语法规则规则进行组织的，其中有几个重要的部分是
    1. variable
    2. array
    3. object
    4. expression，包括函数语句和跳转语句
3. 我们要做的是按照语法规则读取xml文件，并且生成对应的vm代码

## 实现步骤

1. 对目录下各个`.xml`文件进行读取，输出到对应的`.vm`文件
2. 根据语法分析规则解析各个xml文件，根据对应的规则生成对应的xml文件
3. 其中对于identifier，每个.vm文件维护一个大的class scope符号表，每个函数维护他们自己的一个subroutine scope符号表
4. 符号表不会出现在最终的`.vm`代码中，但是我们在生成expression语句和其他语句时，需要从符号表中查找值，并且push/pop到对应的segment

## 实现过程

2. 实现符号表的数据结构（哈希表）, Symbol Table类
3. 实现各个元语句的读写，VMWriter类
4. 实现从`.xml`文件的读取及输出文件的打开
5. 根据语法中对应的规则，实现各个<tag>对应的解析流程，在解析过程中动态创建符号表，并且根据expression生成对应的中间代码，即CodeWriter